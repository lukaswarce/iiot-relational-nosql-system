<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Conceptos InfluxDB - Time Series</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #8e44ad;
            padding-bottom: 10px;
        }
        .mermaid {
            text-align: center;
            margin: 30px 0;
        }
        .concept-box {
            background: #f4ecf7;
            padding: 20px;
            border-left: 4px solid #8e44ad;
            margin: 20px 0;
            border-radius: 5px;
        }
        .code-example {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 15px;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            margin: 15px 0;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚ö° Conceptos Fundamentales - InfluxDB Time-Series</h1>
        
        <h2>Mapa Mental: Estructura InfluxDB</h2>
        <div class="mermaid">
mindmap
  root((InfluxDB))
    Measurement
      Similar a tabla SQL
      Nombre descriptivo
      temperature
      pressure
      vibration
      M√∫ltiples por bucket
    Tags
      Metadatos indexados
      Filtros r√°pidos
      sensor_id
      location
      sensor_type
      Inmutables
    Fields
      Valores medidos
      NO indexados
      temperature valor
      pressure valor
      Pueden cambiar
      Diferentes tipos
    Timestamp
      Nanosegundos precisi√≥n
      √çndice autom√°tico
      Punto en el tiempo
      Clave para queries
      Siempre requerido
        </div>
        
        <div class="concept-box">
            <h3>üìä Anatom√≠a de un Punto de Datos</h3>
            <p><strong>Estructura b√°sica de cada medici√≥n en InfluxDB:</strong></p>
            
            <div class="code-example">
<strong>Formato Line Protocol:</strong>

temperature,sensor_id=TEMP_001,location=Linea_A temperature=75.5 1706934000000000000
‚îÇ           ‚îÇ                                      ‚îÇ              ‚îÇ
‚îÇ           ‚îÇ                                      ‚îÇ              ‚îî‚îÄ Timestamp (nanosegundos)
‚îÇ           ‚îÇ                                      ‚îî‚îÄ Field (valor medido)
‚îÇ           ‚îî‚îÄ Tags (metadatos indexados, separados por comas)
‚îî‚îÄ Measurement (nombre del tipo de medici√≥n)

<strong>Desglose:</strong>
- Measurement: "temperature" (como una tabla)
- Tags: sensor_id=TEMP_001, location=Linea_A (√≠ndices para b√∫squeda r√°pida)
- Field: temperature=75.5 (el valor real medido)
- Timestamp: 1706934000000000000 (momento exacto de la lectura)</div>
        </div>
        
        <h2>üîç Tags vs Fields: ¬øCu√°l usar?</h2>
        <div class="mermaid">
graph TB
    subgraph "Decisi√≥n: ¬øTag o Field?"
        Q{¬øVas a filtrar<br/>por este valor?}
        Q -->|S√ç| TAG[Usar TAG<br/>‚úÖ Indexado<br/>‚úÖ B√∫squeda r√°pida]
        Q -->|NO| FIELD[Usar FIELD<br/>‚úÖ Solo valor<br/>‚úÖ Menos espacio]
    end
    
    subgraph "Ejemplos de TAGS"
        T1[sensor_id]
        T2[location]
        T3[sensor_type]
        T4[unit]
        T5[device_name]
    end
    
    subgraph "Ejemplos de FIELDS"
        F1[temperature valor]
        F2[pressure valor]
        F3[vibration valor]
        F4[count]
        F5[status_code]
    end
    
    TAG --> T1
    TAG --> T2
    TAG --> T3
    TAG --> T4
    TAG --> T5
    
    FIELD --> F1
    FIELD --> F2
    FIELD --> F3
    FIELD --> F4
    FIELD --> F5
    
    style TAG fill:#ccffcc
    style FIELD fill:#cce5ff
        </div>
        
        <div class="concept-box">
            <h3>‚ö° ¬øPor qu√© InfluxDB es TAN R√ÅPIDO?</h3>
            
            <h4>1. Time-Structured Merge Tree (TSM)</h4>
            <div class="code-example">
<strong>Motor de Almacenamiento Optimizado para Tiempo:</strong>

[Escritura en Memoria (Cache)]
         ‚Üì
[WAL - Write-Ahead Log]
         ‚Üì
[Compactaci√≥n peri√≥dica]
         ‚Üì
[TSM Files - Datos comprimidos en disco]

‚úÖ Ventajas:
- Escrituras en memoria primero (muy r√°pidas)
- Compresi√≥n autom√°tica (hasta 90% reducci√≥n)
- Lectura secuencial optimizada
- √çndices de tiempo eficientes</div>
            
            <h4>2. √çndices Autom√°ticos en Tags</h4>
            <div class="code-example">
<strong>B√∫squeda por Tag:</strong>

Query: Temperatura del sensor TEMP_001 en √∫ltima hora

‚ùå MySQL (sin √≠ndice espec√≠fico):
   - Scan de ~3600 filas
   - Tiempo: ~500ms
   - Carga CPU alta

‚úÖ InfluxDB:
   - √çndice directo: Tag[sensor_id=TEMP_001] ‚Üí Bloques de tiempo
   - Tiempo: ~5ms
   - Carga CPU m√≠nima</div>
            
            <h4>3. Compresi√≥n Inteligente</h4>
            <div class="code-example">
<strong>T√©cnicas de Compresi√≥n:</strong>

Datos originales (1 hora de temperatura cada 1 segundo):
3600 puntos √ó 16 bytes = ~57.6 KB

Despu√©s de compresi√≥n InfluxDB:
- Delta encoding (diferencias entre valores)
- Run-length encoding (valores repetidos)
- Gorilla compression (para floats)
Resultado: ~5-8 KB (reducci√≥n ~85%)</div>
        </div>
        
        <h2>Mapa Mental: Consultas Flux</h2>
        <div class="mermaid">
mindmap
  root((Flux<br/>Language))
    Funciones B√°sicas
      from bucket
      range start end
      filter predicados
      yield resultados
      to destino
    Agregaciones
      mean promedio
      sum suma
      count contar
      min m√≠nimo
      max m√°ximo
      median mediana
    Ventanas Temporales
      aggregateWindow
      every duraci√≥n
      fn funci√≥n
      createEmpty
      Agrupaci√≥n temporal
    Transformaciones
      map modificar
      drop eliminar
      keep mantener
      rename cambiar nombre
      duplicate duplicar
    Operadores
      Pipe forward
      Composici√≥n funcional
      Inmutable
      Functional programming
      Type safety
        </div>
        
        <div class="concept-box">
            <h3>üìù Ejemplos de Consultas Flux</h3>
            
            <h4>Consulta B√°sica: √öltima Hora</h4>
            <div class="code-example">
<strong>-- Obtener temperaturas de la √∫ltima hora:</strong>

from(bucket: "iiot_sensors")
  |> range(start: -1h)
  |> filter(fn: (r) => r._measurement == "temperature")
  |> filter(fn: (r) => r._field == "temperature")
  |> filter(fn: (r) => r.sensor_id == "TEMP_001")
  
<strong>Explicaci√≥n:</strong>
1. from() - Define el bucket fuente
2. range() - Ventana de tiempo (√∫ltima 1 hora)
3. filter() - Filtra por measurement (como tabla)
4. filter() - Filtra por field (columna espec√≠fica)
5. filter() - Filtra por tag (sensor espec√≠fico)</div>
            
            <h4>Agregaci√≥n con Ventanas Temporales</h4>
            <div class="code-example">
<strong>-- Temperatura promedio cada 5 minutos:</strong>

from(bucket: "iiot_sensors")
  |> range(start: -24h)
  |> filter(fn: (r) => r._measurement == "temperature")
  |> aggregateWindow(
      every: 5m,           // Ventana de 5 minutos
      fn: mean,            // Calcular promedio
      createEmpty: false   // Omitir ventanas sin datos
  )
  |> yield(name: "temperatura_5min")

<strong>Resultado:</strong>
_time                _value
2026-02-03T00:00:00Z 72.3
2026-02-03T00:05:00Z 73.1
2026-02-03T00:10:00Z 74.5
...</div>
            
            <h4>Downsampling (Reducir Resoluci√≥n)</h4>
            <div class="code-example">
<strong>-- Guardar promedios horarios en nuevo bucket:</strong>

from(bucket: "iiot_sensors")
  |> range(start: -7d)
  |> filter(fn: (r) => r._measurement == "temperature")
  |> aggregateWindow(
      every: 1h,
      fn: mean
  )
  |> to(
      bucket: "iiot_sensors_hourly",  // Bucket para datos reducidos
      org: "iiot-class"
  )

<strong>Beneficio:</strong>
Datos originales: ~604,800 puntos (1 semana, 1 punto/segundo)
Datos reducidos: ~168 puntos (1 semana, 1 punto/hora)
Reducci√≥n: ~99.97% en espacio de almacenamiento</div>
        </div>
        
        <h2>üìà Pol√≠ticas de Retenci√≥n</h2>
        <div class="mermaid">
graph LR
    subgraph "Flujo de Datos a lo Largo del Tiempo"
        A[Datos<br/>Crudos] --> B[30 d√≠as<br/>Resoluci√≥n 1s]
        B --> C[90 d√≠as<br/>Resoluci√≥n 1m]
        C --> D[1 a√±o<br/>Resoluci√≥n 1h]
        D --> E[Permanente<br/>Resoluci√≥n 1d]
        E --> F[Delete<br/>Autom√°tico]
    end
    
    style A fill:#e74c3c
    style B fill:#f39c12
    style C fill:#f1c40f
    style D fill:#52c41a
    style E fill:#1890ff
    style F fill:#8c8c8c
        </div>
        
        <div class="concept-box">
            <h3>üîÑ Configurar Retenci√≥n Autom√°tica</h3>
            <div class="code-example">
<strong>Crear bucket con retenci√≥n de 30 d√≠as:</strong>

influx bucket create \
  --name iiot_sensors_30d \
  --org iiot-class \
  --retention 30d

<strong>Continuous Query (Task) para Downsampling:</strong>

option task = {
  name: "downsample_hourly",
  every: 1h
}

from(bucket: "iiot_sensors")
  |> range(start: -1h)
  |> filter(fn: (r) => r._measurement == "temperature")
  |> aggregateWindow(every: 1h, fn: mean)
  |> to(bucket: "iiot_sensors_historical")

<strong>Efecto:</strong>
‚úÖ Datos antiguos se borran autom√°ticamente
‚úÖ Espacio en disco se mantiene controlado
‚úÖ Datos importantes se preservan en menor resoluci√≥n</div>
        </div>
        
        <h2>üéØ Comparaci√≥n: Query Performance</h2>
        <div class="mermaid">
sequenceDiagram
    participant U as Usuario
    participant M as MySQL
    participant I as InfluxDB
    
    Note over U,I: Query: Temperatura promedio √∫ltima hora
    
    U->>M: SELECT AVG(value)...
    M->>M: Full table scan
    M->>M: Procesar 3600 filas
    M->>M: GROUP BY con timestamp
    M-->>U: ‚è±Ô∏è 500ms
    
    U->>I: from(bucket).range(-1h)...
    I->>I: Buscar en √≠ndice temporal
    I->>I: Leer bloques TSM
    I->>I: Agregaci√≥n optimizada
    I-->>U: ‚ö° 5ms
    
    Note over U,I: InfluxDB es ~100x m√°s r√°pido
        </div>
        
        <div class="concept-box">
            <h3>üí° Casos de Uso Avanzados</h3>
            
            <h4>1. Detecci√≥n de Anomal√≠as</h4>
            <div class="code-example">
<strong>-- Detectar temperaturas fuera del rango normal:</strong>

from(bucket: "iiot_sensors")
  |> range(start: -1h)
  |> filter(fn: (r) => r._measurement == "temperature")
  |> filter(fn: (r) => r._field == "temperature")
  |> map(fn: (r) => ({
      r with
      is_anomaly: r._value > 85.0 or r._value < 20.0
  }))
  |> filter(fn: (r) => r.is_anomaly == true)</div>
            
            <h4>2. Calcular Derivada (Tasa de Cambio)</h4>
            <div class="code-example">
<strong>-- Velocidad de calentamiento (¬∞C por minuto):</strong>

from(bucket: "iiot_sensors")
  |> range(start: -30m)
  |> filter(fn: (r) => r._measurement == "temperature")
  |> derivative(
      unit: 1m,
      nonNegative: false
  )
  |> yield(name: "heating_rate")</div>
            
            <h4>3. Predicci√≥n Lineal</h4>
            <div class="code-example">
<strong>-- Predecir temperatura en 10 minutos:</strong>

from(bucket: "iiot_sensors")
  |> range(start: -1h)
  |> filter(fn: (r) => r._measurement == "temperature")
  |> timedMovingAverage(every: 1m, period: 10m)
  |> holtWinters(
      n: 10,
      seasonality: 4,
      interval: 1m
  )</div>
        </div>
        
        <div class="concept-box">
            <h3>üéØ Beneficios de InfluxDB en IIoT</h3>
            <ul>
                <li><strong>‚ö° Velocidad Extrema</strong> - Millones de escrituras/segundo</li>
                <li><strong>üìä Consultas Temporales Nativas</strong> - Optimizado para tiempo</li>
                <li><strong>üíæ Compresi√≥n Eficiente</strong> - Hasta 90% reducci√≥n de espacio</li>
                <li><strong>üîÑ Retenci√≥n Autom√°tica</strong> - Gesti√≥n de datos hist√≥ricos</li>
                <li><strong>üìà Downsampling</strong> - Reducir resoluci√≥n autom√°ticamente</li>
                <li><strong>üéØ Agregaciones R√°pidas</strong> - Mean, sum, count optimizados</li>
                <li><strong>üîç An√°lisis de Tendencias</strong> - Funciones estad√≠sticas avanzadas</li>
            </ul>
        </div>
    </div>
    
    <script>
        mermaid.initialize({ 
            startOnLoad: true,
            theme: 'default'
        });
    </script>
</body>
</html>
